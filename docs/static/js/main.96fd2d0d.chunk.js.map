{"version":3,"sources":["utils/slate-find-replace.ts","components/FindAndReplace.tsx","components/Editor.tsx","components/App.tsx","index.tsx"],"names":["getSearchRanges","node","path","searchParams","focusedRange","ranges","q","caseSensitive","Text","isText","length","text","search","toLowerCase","parts","split","offset","forEach","part","index","isFocusedSearchHighlight","Path","equals","anchor","focus","push","isSearchHighlight","getAllSearchRanges","editor","children","matchingNodes","Editor","nodes","at","match","includes","nodeMatch","next","done","value","FindAndReplace","setSearchParams","onSearchNext","onSearchPrevious","onReplace","totalSearchResults","searchIndex","React","useState","draftReplace","setDraftReplace","style","border","padding","marginBottom","onChange","evt","currentTarget","marginRight","onClick","all","type","checked","initialValue","useMemo","withHistory","withReact","createEditor","setValue","searchMatchedRanges","setSearchMatchedRanges","searchStep","setSearchStep","useRef","useEffect","step","selection","selectionAnchor","some","r","pathCompare","compare","getNextSearchMatchStep","renderElement","useCallback","props","focusedSearch","renderLeaf","attributes","leaf","color","backgroundColor","decorate","matchedRanges","prevNodePath","originalWordLength","Math","abs","sameNodeAdjustment","range","currentPath","Transforms","insertText","replaceAll","replaceOne","v","firstOperation","operations","App","className","rootElement","document","getElementById","render"],"mappings":"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","file":"static/js/main.96fd2d0d.chunk.js","sourcesContent":["import { Editor, Path, Text, Node, Transforms } from \"slate\";\n\nimport { DecoratedRange, SearchParams } from \"../types\";\n\nexport const MIN_SEARCH_WORD_LENGTH = 0;\n/**\n * Return a list of ranges for which a search parameter exists in a node\n * @param node\n * @param path\n * @param searchParams\n * @param focusedRange If given, will tack on an extra property to the DecoratedRange to\n * show that this range in particular is in focus\n */\nexport const getSearchRanges = (\n  node: Node,\n  path: Path,\n  searchParams: SearchParams,\n  focusedRange?: DecoratedRange\n) => {\n  const ranges: DecoratedRange[] = [];\n  const { q, caseSensitive } = searchParams;\n  // only do a search if it is above the minimum number of characters\n  if (!Text.isText(node) || q.length <= MIN_SEARCH_WORD_LENGTH) {\n    return ranges;\n  }\n\n  let { text } = node;\n\n  // handle casing\n  let search = q;\n  if (!caseSensitive) {\n    text = text.toLowerCase();\n    search = q.toLowerCase();\n  }\n\n  const parts: string[] = text.split(search);\n\n  let offset = 0;\n  parts.forEach((part, index) => {\n    if (index !== 0) {\n      // check if this range is the focused one\n      const isFocusedSearchHighlight =\n        focusedRange &&\n        Path.equals(focusedRange.anchor.path, path) &&\n        focusedRange.focus.offset === offset;\n      ranges.push({\n        anchor: { path, offset: offset - search.length },\n        focus: { path, offset },\n        isSearchHighlight: true,\n        isFocusedSearchHighlight: !!isFocusedSearchHighlight,\n      });\n    }\n\n    offset = offset + part.length + search.length;\n  });\n\n  return ranges;\n};\n\nexport const getAllSearchRanges = (\n  editor: Editor,\n  searchParams: SearchParams\n) => {\n  if (\n    !editor.children.length ||\n    searchParams.q.length <= MIN_SEARCH_WORD_LENGTH\n  ) {\n    return [];\n  }\n\n  const matchingNodes = Editor.nodes(editor, {\n    at: [],\n    match: (node) =>\n      Text.isText(node) &&\n      node.text.toLowerCase().includes(searchParams.q.toLowerCase()),\n  });\n  let nodeMatch = matchingNodes.next();\n  let ranges: DecoratedRange[] = [];\n  while (!nodeMatch.done) {\n    const [node, path] = nodeMatch.value;\n    ranges.push(...getSearchRanges(node, path, searchParams));\n    nodeMatch = matchingNodes.next();\n  }\n  return ranges;\n};\n\nexport const replaceOne = (\n  editor: Editor,\n  text: string,\n  focusedSearch: DecoratedRange\n) => {\n  Transforms.insertText(editor, text, {\n    at: {\n      anchor: focusedSearch.anchor,\n      focus: focusedSearch.focus,\n    },\n  });\n};\n\nexport const replaceAll = (\n  editor: Editor,\n  text: string,\n  matchedRanges: DecoratedRange[]\n) => {\n  if (!matchedRanges.length) {\n    return;\n  }\n  // we run into a problem when the text we are replacing is not the same length\n  // as the text we are replacing it with. we can't just use the ranges we calculated\n  // before because of this. This affects when there's multiple matches within a node,\n  // so we can keep track of the node matches and calculate the offset diff we need to do\n  const originalWordLength = Math.abs(\n    matchedRanges[0].anchor.offset - matchedRanges[0].focus.offset\n  );\n  let sameNodeAdjustment = 0;\n  let prevNodePath: Path | undefined;\n  matchedRanges.forEach((range) => {\n    const currentPath = range.anchor.path;\n    if (prevNodePath && Path.equals(currentPath, prevNodePath)) {\n      // this is not the first instance where we replaced text. we need to calculate\n      // how much our offsets are off by\n      sameNodeAdjustment =\n        sameNodeAdjustment + (text.length - originalWordLength);\n    } else {\n      sameNodeAdjustment = 0;\n    }\n    Transforms.insertText(editor, text, {\n      at: {\n        anchor: {\n          ...range.anchor,\n          offset: range.anchor.offset + sameNodeAdjustment,\n        },\n        focus: {\n          ...range.focus,\n          offset: range.focus.offset + sameNodeAdjustment,\n        },\n      },\n    });\n\n    prevNodePath = range.anchor.path;\n  });\n};\n\n/**\n * Get the next search match based on where the user's selection currently is.\n * We want to get the *next* match after the cursor, so that if the user is looking\n * at the middle of the doc, they aren't brought up to the first match, but rather the\n * next match. Returns a step number\n * @param editor\n * @param ranges\n */\nexport const getNextSearchMatchStep = (\n  editor: Editor,\n  ranges: DecoratedRange[]\n) => {\n  // with the ranges, we should set our step accordingly, based on the editor selection\n  let step = 0;\n  if (editor.selection) {\n    const { anchor: selectionAnchor } = editor.selection;\n    // we want to find the first range that is after the current selection\n    // use .some + return True to mimic 'break' behavior\n    const found = ranges.some((r) => {\n      // returns -1, 0, or 1 for before, at, or after\n      const pathCompare = Path.compare(r.anchor.path, selectionAnchor.path);\n      // this match is above the selection\n      if (pathCompare === -1) {\n        ++step;\n        // this match is in the same node as the selection\n      } else if (pathCompare === 0) {\n        // this match is before the selection\n        if (r.anchor.offset <= selectionAnchor.offset) {\n          ++step;\n          // this match is after the selection, we found the next one\n        } else {\n          return true;\n        }\n      }\n      // this match is in a node after the selection, we found the next one\n      else {\n        return true;\n      }\n      return false;\n    });\n    // we never found a match, could be selection is after ALL matches, so instead set to the first one\n    // could also consider setting to the last one?\n    if (!found) {\n      step = 0;\n    }\n  }\n  return step;\n};\n","import React from \"react\";\nimport { SearchParams, ReplaceParams } from \"../types\";\nimport { MIN_SEARCH_WORD_LENGTH } from \"../utils/slate-find-replace\";\n\ninterface Props {\n  searchParams: SearchParams;\n  setSearchParams: (s: SearchParams) => void;\n  onSearchNext: () => void;\n  onSearchPrevious: () => void;\n  onReplace: (r: ReplaceParams) => void;\n  searchIndex: number;\n  totalSearchResults: number;\n}\nconst FindAndReplace = ({\n  searchParams,\n  setSearchParams,\n  onSearchNext,\n  onSearchPrevious,\n  onReplace,\n  totalSearchResults,\n  searchIndex,\n}: Props) => {\n  const [draftReplace, setDraftReplace] = React.useState(\"\");\n\n  const handleSearchChange = (evt: React.SyntheticEvent<HTMLInputElement>) => {\n    setSearchParams({ ...searchParams, q: evt.currentTarget.value });\n  };\n\n  const handleReplaceChange = (evt: React.SyntheticEvent<HTMLInputElement>) => {\n    setDraftReplace(evt.currentTarget.value);\n  };\n\n  const onReplaceOne = () => {\n    onReplace({ text: draftReplace, all: false });\n  };\n  const onReplaceAll = () => {\n    onReplace({ text: draftReplace, all: true });\n  };\n\n  const toggleCaseSensitive = () => {\n    setSearchParams({\n      ...searchParams,\n      caseSensitive: !searchParams.caseSensitive,\n    });\n  };\n\n  return (\n    <div style={{ border: \"1px solid cornflowerblue\", padding: \"8px\" }}>\n      <div style={{ marginBottom: \"8px\" }}>\n        <input\n          value={searchParams.q}\n          onChange={handleSearchChange}\n          style={{ marginRight: \"4px\" }}\n        ></input>\n\n        <button onClick={onSearchPrevious} style={{ marginRight: \"4px\" }}>\n          Previous\n        </button>\n\n        <button onClick={onSearchNext} style={{ marginRight: \"4px\" }}>\n          Next\n        </button>\n\n        {searchParams.q.length > MIN_SEARCH_WORD_LENGTH && (\n          <span style={{ marginRight: \"4px\" }}>\n            {totalSearchResults === 0 ? 0 : searchIndex + 1} of{\" \"}\n            {totalSearchResults}\n          </span>\n        )}\n      </div>\n      <div>\n        <input\n          value={draftReplace}\n          onChange={handleReplaceChange}\n          style={{ marginRight: \"4px\" }}\n        ></input>\n        <button style={{ marginRight: \"4px\" }} onClick={onReplaceOne}>\n          Replace\n        </button>\n        <button onClick={onReplaceAll}>Replace all</button>\n      </div>\n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={searchParams.caseSensitive}\n            onChange={toggleCaseSensitive}\n          ></input>\n          Case sensitive\n        </label>\n      </div>\n    </div>\n  );\n};\n\nexport default FindAndReplace;\n","import { createEditor, Descendant, NodeEntry, Node } from \"slate\";\nimport React from \"react\";\nimport { withHistory } from \"slate-history\";\nimport {\n  Slate,\n  withReact,\n  Editable,\n  RenderElementProps,\n  RenderLeafProps,\n} from \"slate-react\";\nimport { DecoratedRange, ReplaceParams, SearchParams } from \"../types\";\n\nimport FindAndReplace from \"./FindAndReplace\";\nimport {\n  getAllSearchRanges,\n  getNextSearchMatchStep,\n  getSearchRanges,\n  replaceOne,\n  replaceAll,\n} from \"../utils/slate-find-replace\";\n\nconst initialValue: Descendant[] = [\n  {\n    type: \"paragraph\",\n    children: [\n      {\n        text: \"In my younger and more vulnerable years my father gave me some advice that I’ve been turning over in my mind ever since.\",\n      },\n    ],\n  },\n  {\n    type: \"paragraph\",\n    children: [\n      {\n        text: \"“Whenever you feel like criticizing anyone,” he told me, “just remember that all the people in this world haven’t had the advantages that you’ve had.”\",\n      },\n    ],\n  },\n  {\n    type: \"paragraph\",\n    children: [\n      {\n        text: \"He didn’t say any more, but we’ve always been unusually communicative in a reserved way, and I understood that he meant a great deal more than that. In consequence, I’m inclined to reserve all judgements, a habit that has opened up many curious natures to me and also made me the victim of not a few veteran bores. The abnormal mind is quick to detect and attach itself to this quality when it appears in a normal person, and so it came about that in college I was unjustly accused of being a politician, because I was privy to the secret griefs of wild, unknown men. Most of the confidences were unsought—frequently I have feigned sleep, preoccupation, or a hostile levity when I realized by some unmistakable sign that an intimate revelation was quivering on the horizon; for the intimate revelations of young men, or at least the terms in which they express them, are usually plagiaristic and marred by obvious suppressions. Reserving judgements is a matter of infinite hope. I am still a little afraid of missing something if I forget that, as my father snobbishly suggested, and I snobbishly repeat, a sense of the fundamental decencies is parcelled out unequally at birth.\",\n      },\n    ],\n  },\n  {\n    type: \"paragraph\",\n    children: [\n      {\n        text: \"And, after boasting this way of my tolerance, I come to the admission that it has a limit. Conduct may be founded on the hard rock or the wet marshes, but after a certain point I don’t care what it’s founded on. When I came back from the East last autumn I felt that I wanted the world to be in uniform and at a sort of moral attention forever; I wanted no more riotous excursions with privileged glimpses into the human heart. Only Gatsby, the man who gives his name to this book, was exempt from my reaction—Gatsby, who represented everything for which I have an unaffected scorn. If personality is an unbroken series of successful gestures, then there was something gorgeous about him, some heightened sensitivity to the promises of life, as if he were related to one of those intricate machines that register earthquakes ten thousand miles away. This responsiveness had nothing to do with that flabby impressionability which is dignified under the name of the “creative temperament”—it was an extraordinary gift for hope, a romantic readiness such as I have never found in any other person and which it is not likely I shall ever find again. No—Gatsby turned out all right at the end; it is what preyed on Gatsby, what foul dust floated in the wake of his dreams that temporarily closed out my interest in the abortive sorrows and short-winded elations of men.\",\n      },\n    ],\n  },\n];\n\nconst Editor = () => {\n  const editor = React.useMemo(\n    () => withHistory(withReact(createEditor())),\n    []\n  );\n  const [value, setValue] = React.useState<Descendant[]>(initialValue);\n  const [searchParams, setSearchParams] = React.useState<SearchParams>({\n    q: \"\",\n    caseSensitive: false,\n  });\n  const [searchMatchedRanges, setSearchMatchedRanges] = React.useState<\n    DecoratedRange[]\n  >([]);\n  const [searchStep, setSearchStep] = React.useState(0);\n\n  const handleChange = (v: Descendant[]) => {\n    const { operations } = editor;\n    const firstOperation = operations[0];\n    if (\n      firstOperation &&\n      (firstOperation.type === \"insert_text\" ||\n        firstOperation.type === \"remove_text\")\n    ) {\n      const ranges = getAllSearchRanges(editor, searchParams);\n      setSearchMatchedRanges(ranges);\n    }\n    setValue(v);\n  };\n  const searchRef = React.useRef<HTMLSpanElement>(null);\n\n  const handleSearchNext = () => {\n    if (searchStep >= searchMatchedRanges.length - 1) {\n      setSearchStep(0);\n    } else {\n      setSearchStep(searchStep + 1);\n    }\n  };\n  const handleSearchPrevious = () => {\n    if (searchStep === 0) {\n      setSearchStep(searchMatchedRanges.length - 1);\n    } else {\n      setSearchStep(searchStep - 1);\n    }\n  };\n\n  React.useEffect(() => {\n    const ranges = getAllSearchRanges(editor, searchParams);\n    setSearchMatchedRanges(ranges);\n\n    const step = getNextSearchMatchStep(editor, ranges);\n    setSearchStep(step);\n  }, [searchParams, editor]);\n\n  const renderElement = React.useCallback((props: RenderElementProps) => {\n    return <p {...props}></p>;\n  }, []);\n\n  const focusedSearch = searchMatchedRanges[searchStep];\n\n  const handleReplace = (r: ReplaceParams) => {\n    if (r.all) {\n      replaceAll(editor, r.text, searchMatchedRanges);\n    } else {\n      replaceOne(editor, r.text, focusedSearch);\n    }\n  };\n\n  const renderLeaf = React.useCallback(\n    ({ attributes, children, leaf }: RenderLeafProps) => {\n      let color = \"transparent\";\n      if (leaf.isFocusedSearchHighlight) {\n        color = \"peachpuff\";\n      } else if (leaf.isSearchHighlight) {\n        color = \"gainsboro\";\n      }\n      return (\n        <span\n          {...attributes}\n          {...(leaf.isFocusedSearchHighlight && {\n            \"data-testid\": \"search-focused\",\n          })}\n          style={{\n            backgroundColor: color,\n          }}\n        >\n          {children}\n        </span>\n      );\n    },\n    []\n  );\n\n  const decorate = React.useCallback(\n    ([node, path]: NodeEntry<Node>) => {\n      return getSearchRanges(node, path, searchParams, focusedSearch);\n    },\n    [focusedSearch, searchParams]\n  );\n\n  return (\n    <div>\n      <FindAndReplace\n        searchParams={searchParams}\n        setSearchParams={setSearchParams}\n        onSearchNext={handleSearchNext}\n        onSearchPrevious={handleSearchPrevious}\n        onReplace={handleReplace}\n        searchIndex={searchStep}\n        totalSearchResults={searchMatchedRanges.length}\n      />\n      {value.length > 0 && (\n        <Slate editor={editor} value={value} onChange={handleChange}>\n          <Editable\n            renderElement={renderElement}\n            renderLeaf={renderLeaf}\n            decorate={decorate}\n          />\n        </Slate>\n      )}\n    </div>\n  );\n};\n\nexport default Editor;\n","import Editor from \"./Editor\";\n\nimport \"../styles.css\";\n\nexport default function App() {\n  return (\n    <div className=\"App\">\n      <div className=\"content\">\n        <h1>Slate find & replace!</h1>\n        <p>ft. The Great Gatsby</p>\n        <Editor />\n      </div>\n    </div>\n  );\n}\n","import { render } from \"react-dom\";\n\nimport App from \"./components/App\";\n\nconst rootElement = document.getElementById(\"root\");\nrender(<App />, rootElement);\n"],"sourceRoot":""}